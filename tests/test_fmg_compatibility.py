"""
FMG Compatibility Tests

Tests to verify that our Python implementation produces identical results
to the original FMG JavaScript code using reference data.

This test suite implements the verification protocol described in compat.md.
"""

import json
import pytest
import numpy as np
from pathlib import Path

from py_fmg.core.voronoi_graph import GridConfig, generate_voronoi_graph


class TestVoronoiTopologyCompatibility:
    """
    Priority 1 compatibility test: Verify Voronoi graph topology matches FMG reference.

    This test loads the reference JSON file generated by FMG with seed "415283749"
    and verifies that our Python implementation produces identical topological structure.
    """

    @classmethod
    def setup_class(cls):
        """Load the FMG reference data once for all tests."""
        reference_path = Path(__file__).parent / "Mateau Full 2025-07-27-14-53.json"

        if not reference_path.exists():
            pytest.skip(f"Reference file not found: {reference_path}")

        with open(reference_path, "r") as f:
            cls.fmg_data = json.load(f)

        # Extract key parameters - use grid data for topology testing
        cls.seed = str(cls.fmg_data["info"]["seed"])
        cls.width = cls.fmg_data["info"]["width"]
        cls.height = cls.fmg_data["info"]["height"]
        cls.grid = cls.fmg_data["grid"]
        cls.cells_desired = cls.grid["cellsDesired"]
        cls.spacing = cls.grid["spacing"]
        cls.cells_x = cls.grid["cellsX"]
        cls.cells_y = cls.grid["cellsY"]
        cls.grid_points = cls.grid["points"]
        cls.n_cells = len(cls.grid_points)

        # Also load pack data for future testing
        cls.pack_cells = cls.fmg_data["pack"]["cells"]

        print(
            f"Loaded reference data: seed={cls.seed}, dimensions={cls.width}x{cls.height}, cells={cls.n_cells}"
        )

    def test_seed_and_dimensions_match(self):
        """Verify we have the expected reference data."""
        assert self.seed == "651658815", f"Expected seed 651658815, got {self.seed}"
        assert self.width == 300, f"Expected width 300, got {self.width}"
        assert self.height == 300, f"Expected height 300, got {self.height}"
        assert self.n_cells == 10000, f"Expected 10000 cells, got {self.n_cells}"

    def test_point_coordinates_exact_match(self):
        """
        Test 1: Verify that our jittered grid produces identical point coordinates.

        This validates that our get_jittered_grid() function with the same seed
        produces numerically identical results to FMG's getJitteredGrid().
        """
        # Generate our Python graph
        config = GridConfig(
            width=self.width,
            height=self.height,
            cells_desired=self.cells_desired,  # Use FMG's cellsDesired parameter
        )

        # Use seed 1234567 because FMG reused the grid from that generation
        # (as shown in console output - no placePoints after seed 651658815)
        python_graph = generate_voronoi_graph(config, seed="1234567")

        # Extract reference grid points (not pack.cells points)
        fmg_points = np.array(self.grid_points)

        print(f"Python generated {len(python_graph.points)} points")
        print(f"FMG reference has {len(fmg_points)} points")

        # Must have same number of points
        assert len(python_graph.points) == len(
            fmg_points
        ), f"Point count mismatch: Python={len(python_graph.points)}, FMG={len(fmg_points)}"

        # Compare coordinates with tolerance for floating point precision
        np.testing.assert_allclose(
            python_graph.points,
            fmg_points,
            rtol=1e-10,
            atol=1e-10,
            err_msg="Point coordinates do not match FMG reference data",
        )

        print("✅ Point coordinates match exactly!")

    def test_neighbor_topology_exact_match(self):
        """
        Test 2: Verify that cell neighbor topology is identical.

        This is the MOST CRITICAL test. Every cell must have exactly the same
        neighbors as in the FMG reference data.
        """
        # Generate our Python graph
        config = GridConfig(
            width=self.width, height=self.height, cells_desired=self.cells_desired
        )

        # Use seed 1234567 because FMG reused the grid from that generation
        python_graph = generate_voronoi_graph(config, seed="1234567")

        # Track topology mismatches for detailed reporting
        mismatches = []
        total_checks = 0

        # Use grid cells for connectivity testing
        grid_cells = self.grid["cells"]

        for i in range(len(python_graph.cell_neighbors)):
            if i >= len(grid_cells):
                break

            py_neighbors = set(python_graph.cell_neighbors[i])
            fmg_neighbors = set(grid_cells[i]["c"])

            total_checks += 1

            if py_neighbors != fmg_neighbors:
                mismatches.append(
                    {
                        "cell": i,
                        "python": sorted(py_neighbors),
                        "fmg": sorted(fmg_neighbors),
                        "python_only": sorted(py_neighbors - fmg_neighbors),
                        "fmg_only": sorted(fmg_neighbors - py_neighbors),
                    }
                )

        # Report results
        print(f"Checked {total_checks} cells for neighbor topology")
        print(f"Found {len(mismatches)} mismatches")

        if mismatches:
            print("\nFirst 5 topology mismatches:")
            for mismatch in mismatches[:5]:
                print(f"Cell {mismatch['cell']}:")
                print(f"  Python:  {mismatch['python']}")
                print(f"  FMG:     {mismatch['fmg']}")
                print(f"  Py only: {mismatch['python_only']}")
                print(f"  FMG only: {mismatch['fmg_only']}")

        # Fail if any mismatches found
        assert (
            len(mismatches) == 0
        ), f"Found {len(mismatches)} topology mismatches out of {total_checks} cells"

        print("✅ Neighbor topology matches exactly!")

    def test_vertex_connectivity_match(self):
        """
        Test 3: Verify that cell-vertex connectivity is correct.

        While vertex coordinates may differ slightly due to numerical precision,
        the connectivity structure must be identical.
        """
        # Generate our Python graph
        config = GridConfig(
            width=self.width, height=self.height, cells_desired=self.cells_desired
        )

        # Use seed 1234567 because FMG reused the grid from that generation
        python_graph = generate_voronoi_graph(config, seed="1234567")

        # Track vertex connectivity mismatches
        mismatches = []
        total_checks = 0

        # Use grid cells for vertex connectivity testing
        grid_cells = self.grid["cells"]

        for i in range(len(python_graph.cell_vertices)):
            if i >= len(grid_cells):
                break

            py_vertices = set(python_graph.cell_vertices[i])
            fmg_vertices = set(grid_cells[i]["v"])

            total_checks += 1

            # Allow for different vertex indexing, but check count consistency
            if len(py_vertices) != len(fmg_vertices):
                mismatches.append(
                    {
                        "cell": i,
                        "python_count": len(py_vertices),
                        "fmg_count": len(fmg_vertices),
                        "python_vertices": sorted(py_vertices),
                        "fmg_vertices": sorted(fmg_vertices),
                    }
                )

        print(f"Checked {total_checks} cells for vertex connectivity")
        print(f"Found {len(mismatches)} vertex count mismatches")

        if mismatches:
            print("\nFirst 5 vertex connectivity mismatches:")
            for mismatch in mismatches[:5]:
                print(
                    f"Cell {mismatch['cell']}: Python={mismatch['python_count']} vertices, FMG={mismatch['fmg_count']} vertices"
                )

        # Allow some tolerance for vertex connectivity differences due to implementation
        mismatch_rate = len(mismatches) / total_checks if total_checks > 0 else 0
        assert (
            mismatch_rate < 0.05
        ), f"Too many vertex connectivity mismatches: {mismatch_rate:.2%} (>{5}%)"

        print(f"✅ Vertex connectivity acceptable (mismatch rate: {mismatch_rate:.2%})")

    def test_border_cell_detection(self):
        """
        Test 4: Verify border cell detection matches FMG.

        Border cells in FMG are those that touch the map boundary.
        """
        # Generate our Python graph
        config = GridConfig(
            width=self.width, height=self.height, cells_desired=self.n_cells
        )

        # Use seed 1234567 because FMG reused the grid from that generation
        python_graph = generate_voronoi_graph(config, seed="1234567")

        # Count border cells in our implementation
        py_border_count = np.sum(python_graph.cell_border_flags)

        # FMG stores border flags in the 'b' field
        fmg_border_count = sum(
            1 for cell in self.grid["cells"] if cell.get("b", 0) == 1
        )

        print(f"Python border cells: {py_border_count}")
        print(f"FMG border cells: {fmg_border_count}")

        # Border detection should match exactly
        assert (
            py_border_count == fmg_border_count
        ), f"Border cell count mismatch: Python={py_border_count}, FMG={fmg_border_count}"

        print("✅ Border cell detection matches exactly!")

    @pytest.mark.slow
    def test_reproducibility_with_reference_seed(self):
        """
        Test 5: Verify that multiple runs with the same seed produce identical results.

        This ensures our random number generation is deterministic like FMG's.
        """
        config = GridConfig(
            width=self.width, height=self.height, cells_desired=self.n_cells
        )

        # Generate graph multiple times with same seed
        graph1 = generate_voronoi_graph(config, seed=self.seed)
        graph2 = generate_voronoi_graph(config, seed=self.seed)

        # Should be identical
        np.testing.assert_array_equal(graph1.points, graph2.points)
        assert graph1.cell_neighbors == graph2.cell_neighbors
        np.testing.assert_array_equal(
            graph1.cell_border_flags, graph2.cell_border_flags
        )

        print("✅ Reproducibility verified with reference seed")


class TestReferenceDataStructure:
    """
    Utility tests to understand and validate the reference data structure.

    These tests help ensure we're interpreting the FMG data correctly.
    """

    @classmethod
    def setup_class(cls):
        """Load reference data."""
        reference_path = Path(__file__).parent / "Joyerland Full 2025-07-27-14-29.json"

        if not reference_path.exists():
            pytest.skip(f"Reference file not found: {reference_path}")

        with open(reference_path, "r") as f:
            cls.data = json.load(f)

    def test_reference_data_completeness(self):
        """Verify the reference data contains all expected fields."""
        # Top-level structure
        assert "info" in self.data
        assert "pack" in self.data
        assert "grid" in self.data

        # Info section
        info = self.data["info"]
        assert "seed" in info
        assert "width" in info
        assert "height" in info

        # Pack section
        pack = self.data["pack"]
        assert "cells" in pack
        assert "vertices" in pack

        print("✅ Reference data structure is complete")

    def test_cell_data_fields(self):
        """Verify cell data contains expected fields for future tests."""
        cells = self.data["pack"]["cells"]

        if not cells:
            pytest.skip("No cells in reference data")

        # Check first cell has expected fields
        first_cell = cells[0]
        required_fields = ["i", "p", "c", "v"]  # Index, position, connections, vertices
        optional_fields = [
            "h",
            "f",
            "fl",
            "r",
            "biome",
            "pop",
            "burg",
            "state",
        ]  # For future tests

        for field in required_fields:
            assert (
                field in first_cell
            ), f"Required field '{field}' missing from cell data"

        # Report available optional fields
        available_optional = [f for f in optional_fields if f in first_cell]
        print(f"Available optional fields: {available_optional}")

        print("✅ Cell data fields verified for topology testing")

    def test_topology_sanity_checks(self):
        """Basic sanity checks on the reference topology data."""
        cells = self.data["pack"]["cells"]

        # Check that neighbor relationships are symmetric
        asymmetric_count = 0
        total_edges = 0

        for i, cell in enumerate(cells[:100]):  # Sample first 100 cells
            for neighbor_id in cell["c"]:
                total_edges += 1
                if neighbor_id < len(cells):
                    neighbor_cell = cells[neighbor_id]
                    if i not in neighbor_cell["c"]:
                        asymmetric_count += 1

        asymmetric_rate = asymmetric_count / total_edges if total_edges > 0 else 0

        print(f"Checked {total_edges} neighbor relationships")
        print(
            f"Found {asymmetric_count} asymmetric relationships ({asymmetric_rate:.2%})"
        )

        # Some asymmetry is expected due to boundary conditions
        assert (
            asymmetric_rate < 0.1
        ), f"Too many asymmetric relationships: {asymmetric_rate:.2%}"

        print("✅ Reference topology passes sanity checks")


# Pytest configuration for this module
def pytest_configure(config):
    """Add custom markers."""
    config.addinivalue_line(
        "markers", "slow: marks tests as slow (deselect with '-m \"not slow\"')"
    )
