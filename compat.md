### **Subject: Technical Specification for FMG Compatibility Testing**

**To:** Development Team
**From:** Senior Analyst
**Re:** Verification against FMG JSON Export (`/home/user/py-fmg/tests/Joyerland Full 2025-07-27-14-29.json`)

This document outlines the verification protocol for our Python FMG port. The provided JSON file represents the ground truth for a map generated with `seed: "415283749"`. Our Python implementation, when given the same seed and map dimensions, **must** reproduce the structural and, eventually, the attribute data contained within the `pack` object.

This verification will be done in stages, mirroring the `TASKS.md`. The immediate priority is **Topological Equivalence**.

### **Priority 1: Voronoi Graph Compatibility Test (Task 8)**

The goal of this test is to prove that our Python-generated graph has the **exact same structure** as the FMG reference graph. The test should load this JSON file and compare the Python graph's properties against the following specific fields within `pack.cells`.

For each cell `i` in the graph:

1.  **Point Coordinates (`pack.cells[i].p`)**
    *   **What it is:** The `[x, y]` coordinate of the Voronoi seed point for cell `i`.
    *   **Verification:** Your `get_jittered_grid()` function, when run with the seed `"415283749"`, must produce an array of points that is numerically identical to the `p` values extracted from `pack.cells`. This validates your jittering algorithm.

2.  **Neighbor Topology (`pack.cells[i].c`)**
    *   **What it is:** A list of the indices of all cells that are direct neighbors to cell `i`.
    *   **Verification:** This is the **most critical test**. For every cell `i`, the set of neighbors generated by your Python code must be identical to the set of values in `pack.cells[i].c`.
    *   **Example Test Logic:**
        ```python
        # For each cell i from 0 to N-1
        py_neighbors = set(python_graph.cell_neighbors[i])
        fmg_neighbors = set(reference_json.pack.cells[i].c)
        assert py_neighbors == fmg_neighbors, f"Topology mismatch for cell {i}"
        ```

3.  **Vertex Connectivity (`pack.cells[i].v`)**
    *   **What it is:** A list of the indices of the vertices that form the polygon boundary of cell `i`.
    *   **Verification:** While the geometric coordinates of the vertices can be tested later, the *connectivity* must be correct now. Your Python graph must correctly associate each cell with a list of vertex indices, and this list must match the one in `pack.cells[i].v`. This ensures that when you build the polygons later, they will have the correct shape.

### **Priority 2: Data for Subsequent Test Stages**

This JSON file is the reference for the entire project. Once the graph topology is verified, subsequent modules will be tested against these other fields. Your developers should be aware of what they will be targeting next.

*   **For Heightmap Generation (Task 9):**
    *   Verify against `pack.cells[i].h` (height).

*   **For Geographic Features (Task 10):**
    *   Verify against `pack.cells[i].f` (feature type, e.g., ocean/land).

*   **For Hydrology System (Task 11):**
    *   Verify against `pack.cells[i].fl` (flux) and `pack.cells[i].r` (river ID).

*   **For Biome Assignment (Task 12):**
    *   Verify against `pack.cells[i].biome`.

*   **For Settlement System (Task 13):**
    *   Verify against `pack.cells[i].pop` (population), `pack.cells[i].burg` (burg ID), and `pack.cells[i].state` (state ID).

### **Critical Note on Data Structures**

The FMG `pack` format is highly optimized, using short, non-descriptive keys (`c`, `v`, `h`, etc.). Our internal Python objects **should not** mimic this. We will use descriptive data classes or Pydantic models (e.g., `cell.neighbors`, `cell.height`).

The goal of the compatibility tests is to verify that the **data values** are identical, not that the data structures are. The tests will act as an "adapter," reading the FMG JSON and comparing its values to the values held in our more readable, Pythonic objects.
