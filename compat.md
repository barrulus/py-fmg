### **Subject: Technical Specification for FMG Compatibility Testing**

**To:** Development Team
**From:** Senior Analyst
**Re:** Verification against FMG JSON Export (`/home/user/py-fmg/tests/Joyerland Full 2025-07-27-14-29.json`)

This document outlines the verification protocol for our Python FMG port. The provided JSON file represents the ground truth for a map generated with `seed: "415283749"`. Our Python implementation, when given the same seed and map dimensions, **must** reproduce the structural and, eventually, the attribute data contained within the `pack` object.

This verification will be done in stages, mirroring the `TASKS.md`. The immediate priority is **Topological Equivalence**.

### **Priority 1: Voronoi Graph Compatibility Test (Task 8)**

The goal of this test is to prove that our Python-generated graph has the **exact same structure** as the FMG reference graph. The test should load this JSON file and compare the Python graph's properties against the following specific fields within `pack.cells`.

For each cell `i` in the graph:

1.  **Point Coordinates (`pack.cells[i].p`)**
    *   **What it is:** The `[x, y]` coordinate of the Voronoi seed point for cell `i`.
    *   **Verification:** Your `get_jittered_grid()` function, when run with the seed `"415283749"`, must produce an array of points that is numerically identical to the `p` values extracted from `pack.cells`. This validates your jittering algorithm.

2.  **Neighbor Topology (`pack.cells[i].c`)**
    *   **What it is:** A list of the indices of all cells that are direct neighbors to cell `i`.
    *   **Verification:** This is the **most critical test**. For every cell `i`, the set of neighbors generated by your Python code must be identical to the set of values in `pack.cells[i].c`.
    *   **Example Test Logic:**
        ```python
        # For each cell i from 0 to N-1
        py_neighbors = set(python_graph.cell_neighbors[i])
        fmg_neighbors = set(reference_json.pack.cells[i].c)
        assert py_neighbors == fmg_neighbors, f"Topology mismatch for cell {i}"
        ```

3.  **Vertex Connectivity (`pack.cells[i].v`)**
    *   **What it is:** A list of the indices of the vertices that form the polygon boundary of cell `i`.
    *   **Verification:** While the geometric coordinates of the vertices can be tested later, the *connectivity* must be correct now. Your Python graph must correctly associate each cell with a list of vertex indices, and this list must match the one in `pack.cells[i].v`. This ensures that when you build the polygons later, they will have the correct shape.

### **Priority 2: Data for Subsequent Test Stages**

This JSON file is the reference for the entire project. Once the graph topology is verified, subsequent modules will be tested against these other fields. Your developers should be aware of what they will be targeting next.

*   **For Heightmap Generation (Task 9):**
    *   Verify against `pack.cells[i].h` (height).

*   **For Geographic Features (Task 10):**
    *   Verify against `pack.cells[i].f` (feature type, e.g., ocean/land).

*   **For Hydrology System (Task 11):**
    *   Verify against `pack.cells[i].fl` (flux) and `pack.cells[i].r` (river ID).

*   **For Biome Assignment (Task 12):**
    *   Verify against `pack.cells[i].biome`.

*   **For Settlement System (Task 13):**
    *   Verify against `pack.cells[i].pop` (population), `pack.cells[i].burg` (burg ID), and `pack.cells[i].state` (state ID).

### **Critical Note on Data Structures**

The FMG `pack` format is highly optimized, using short, non-descriptive keys (`c`, `v`, `h`, etc.). Our internal Python objects **should not** mimic this. We will use descriptive data classes or Pydantic models (e.g., `cell.neighbors`, `cell.height`).

The goal of the compatibility tests is to verify that the **data values** are identical, not that the data structures are. The tests will act as an "adapter," reading the FMG JSON and comparing its values to the values held in our more readable, Pythonic objects.

## Heightmap tests

### **What These Tests Are Testing Correctly**

This test suite successfully validates three critical aspects of the `HeightmapGenerator`:

**1. Correctness of Individual Operations (The "Brushes"):**
*   The `TestHeightmapGenerator` class methodically tests each "brush" in your toolkit (`add_hill`, `add_pit`, `add_range`, `smooth`, `mask`, `modify`, `add_strait`).
*   **Why it's right:** Instead of just checking that the code runs, the tests validate the *expected outcome*. For example, `test_smooth_operation` correctly asserts that the standard deviation of heights *decreases*, which is the mathematical goal of smoothing. `test_mask_operation` correctly asserts that edge cells are lower than center cells. This is a very effective way to test procedural algorithms.

**2. Fidelity of Template-Based Generation (The "Macros"):**
*   The tests for `test_template_volcano` and `test_template_archipelago` are excellent. They don't just check for completion; they test the *character* of the output.
*   **Why it's right:** A volcano should have a high peak and low surroundings. An archipelago should have a specific ratio of land to water. By testing these statistical properties, you are confirming that your Python port is not just running the commands, but is achieving the same *artistic and geographic intent* as the original FMG templates.
*   The `test_all_templates_valid` is a fantastic smoke test that ensures no template will crash the system.

**3. Robustness and Determinism (The "Guarantees"):**
*   **`test_reproducibility`:** This is a non-negotiable, critical test. It proves that for a given seed, the generator produces the exact same heightmap every single time. You can trust that your world generation is deterministic.
*   **`TestHeightmapBoundaryConditions`:** This class shows foresight. By testing on a tiny graph with extreme parameters, you are stress-testing the mathematical formulas and clamping logic (e.g., ensuring height never goes above 100 or below 0). This prevents a huge class of bugs related to edge cases.

### **Where These Tests Fit in the Project Plan**

*   **Task 9 (Heightmap Generation):** These tests provide comprehensive coverage for the porting of the heightmap templates and procedural algorithms. You can confidently mark the implementation portion of this task as complete and well-tested.

*   **Foundation for Future Tasks:** A correctly functioning heightmap is the canvas upon which all subsequent features are painted.
    *   **Task 10 (Geographic Features):** Your land/ocean classification depends entirely on the output of this module.
    *   **Task 11 (Climate):** Temperature depends on altitude (`heights`).
    *   **Task 12 (Hydrology):** River flow is entirely driven by the gradient of the heightmap.

Because these tests are passing, you have built a solid foundation and de-risked all of these future dependent tasks.

### **The Next Logical Step: The Compatibility Test**

Just like with the Voronoi graph, the current tests prove your module's **internal validity**. The final "stage-gate" test is to prove its **external compatibility** with FMG.

The next step is to create `test_heightmap_compatibility.py`. This test will:

1.  **Load Reference Data:** Use the same FMG reference JSON file from the previous compatibility test.
2.  **Generate a Python Heightmap:** Run your `HeightmapGenerator` using the *exact same seed and template* that were used to generate the reference file.
3.  **Compare the Arrays:** Extract the final height array (`pack.cells[i].h`) from the FMG JSON and compare it to the `heights` array produced by your Python code.

```python
# Conceptual compatibility test
def test_heightmap_matches_fmg_reference():
    # 1. Load the reference FMG JSON
    fmg_data = load_fmg_reference_data()
    fmg_heights = np.array([cell['h'] for cell in fmg_data['pack']['cells']])

    # 2. Generate the Python heightmap with the same seed and template
    # (Requires having the Voronoi graph from the compatibility test available)
    python_graph = generate_fmg_compatible_graph(fmg_data['info']['seed'])
    heightmap_gen = HeightmapGenerator(config, python_graph)
    python_heights = heightmap_gen.from_template(
        template=get_template(fmg_data['settings']['template']), # Assuming template name is in settings
        seed=fmg_data['info']['seed']
    )

    # 3. Assert that the arrays are identical
    np.testing.assert_array_equal(python_heights, fmg_heights)

```
